# Prompt Memo VSCode拡張機能 テスト計画書

## 1. テスト戦略

### 1.1 テストレベル
1. **単体テスト（Unit Test）**
   - 個別関数・メソッドのテスト
   - モック/スタブを使用した分離テスト

2. **統合テスト（Integration Test）**
   - コンポーネント間の連携テスト
   - VSCode APIとの統合テスト

3. **E2Eテスト（End-to-End Test）**
   - ユーザーシナリオベースのテスト
   - 実際のVSCode環境でのテスト

### 1.2 テストツール
- **テストフレームワーク**: Mocha
- **アサーション**: Chai
- **モック**: Sinon
- **VSCodeテスト**: @vscode/test-electron

## 2. テストケース

### 2.1 単体テスト

#### UUID生成機能
```typescript
describe('UUID Generator', () => {
    it('should generate valid UUID format', () => {
        const uuid = generateUUID();
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
        assert.match(uuid, uuidRegex);
    });
    
    it('should generate unique UUIDs', () => {
        const uuid1 = generateUUID();
        const uuid2 = generateUUID();
        assert.notEqual(uuid1, uuid2);
    });
});
```

#### Memoモデル
```typescript
describe('Memo Model', () => {
    it('should create memo with all required properties', () => {
        const memo = new Memo('test content');
        assert.exists(memo.id);
        assert.equal(memo.content, 'test content');
        assert.exists(memo.createdAt);
        assert.exists(memo.updatedAt);
    });
    
    it('should validate content length', () => {
        const longContent = 'a'.repeat(10001);
        assert.throws(() => new Memo(longContent), /Content too long/);
    });
});
```

### 2.2 統合テスト

#### MemoViewProvider
```typescript
describe('MemoViewProvider', () => {
    let context: vscode.ExtensionContext;
    let provider: MemoViewProvider;
    
    beforeEach(() => {
        context = createMockContext();
        provider = new MemoViewProvider(context);
    });
    
    it('should load saved memos on initialization', async () => {
        const savedMemos = [
            { id: '1', content: 'Test 1', createdAt: 1, updatedAt: 1 }
        ];
        context.workspaceState.get.returns(savedMemos);
        
        await provider.loadMemos();
        assert.equal(provider.getMemos().length, 1);
    });
    
    it('should create new memo', async () => {
        await provider.createMemo();
        assert.equal(provider.getMemos().length, 1);
        assert(context.workspaceState.update.calledOnce);
    });
    
    it('should update existing memo', async () => {
        await provider.createMemo();
        const memo = provider.getMemos()[0];
        
        await provider.updateMemo(memo.id, 'Updated content');
        assert.equal(memo.content, 'Updated content');
    });
    
    it('should delete memo', async () => {
        await provider.createMemo();
        const memo = provider.getMemos()[0];
        
        await provider.deleteMemo(memo.id);
        assert.equal(provider.getMemos().length, 0);
    });
});
```

#### Webviewメッセージング
```typescript
describe('Webview Messaging', () => {
    it('should handle createMemo message', async () => {
        const message = { command: 'createMemo' };
        await provider.handleMessage(message);
        
        assert(createMemoSpy.calledOnce);
    });
    
    it('should handle updateMemo message', async () => {
        const message = { 
            command: 'updateMemo',
            id: '123',
            content: 'New content'
        };
        await provider.handleMessage(message);
        
        assert(updateMemoSpy.calledWith('123', 'New content'));
    });
    
    it('should send memos to webview', async () => {
        const memos = [{ id: '1', content: 'Test', createdAt: 1, updatedAt: 1 }];
        provider.setMemos(memos);
        
        await provider.updateWebview();
        
        assert(postMessageSpy.calledWith({
            command: 'setMemos',
            memos: memos
        }));
    });
});
```

### 2.3 E2Eテスト

#### ユーザーシナリオ
```typescript
describe('E2E User Scenarios', () => {
    it('should complete basic memo workflow', async () => {
        // 1. 拡張機能を開く
        await vscode.commands.executeCommand('promptMemo.focus');
        
        // 2. 新規メモを作成
        await vscode.commands.executeCommand('promptMemo.createMemo');
        
        // 3. メモに内容を入力
        await typeInWebview('This is my first memo');
        
        // 4. 別のメモを作成
        await vscode.commands.executeCommand('promptMemo.createMemo');
        await typeInWebview('Second memo');
        
        // 5. 最初のメモを削除
        await clickDeleteButton(0);
        
        // 6. 残りのメモを確認
        const memos = await getMemosFromWebview();
        assert.equal(memos.length, 1);
        assert.equal(memos[0].content, 'Second memo');
    });
    
    it('should persist memos across reload', async () => {
        // メモを作成
        await vscode.commands.executeCommand('promptMemo.createMemo');
        await typeInWebview('Persistent memo');
        
        // 拡張機能をリロード
        await vscode.commands.executeCommand('workbench.action.reloadWindow');
        
        // メモが復元されているか確認
        await vscode.commands.executeCommand('promptMemo.focus');
        const memos = await getMemosFromWebview();
        assert.equal(memos.length, 1);
        assert.equal(memos[0].content, 'Persistent memo');
    });
});
```

## 3. パフォーマンステスト

### 3.1 負荷テスト
```typescript
describe('Performance Tests', () => {
    it('should handle 100 memos efficiently', async () => {
        const startTime = Date.now();
        
        for (let i = 0; i < 100; i++) {
            await provider.createMemo();
            await provider.updateMemo(
                provider.getMemos()[i].id,
                `Memo ${i}`
            );
        }
        
        const endTime = Date.now();
        const duration = endTime - startTime;
        
        assert.isBelow(duration, 5000, 'Should complete within 5 seconds');
    });
    
    it('should render large memo content without lag', async () => {
        const largeContent = 'Lorem ipsum '.repeat(1000);
        await provider.createMemo();
        
        const startTime = Date.now();
        await provider.updateMemo(
            provider.getMemos()[0].id,
            largeContent
        );
        const endTime = Date.now();
        
        assert.isBelow(endTime - startTime, 100, 'Should update within 100ms');
    });
});
```

### 3.2 メモリ使用量テスト
```typescript
describe('Memory Usage', () => {
    it('should not leak memory on repeated operations', async () => {
        const initialMemory = process.memoryUsage().heapUsed;
        
        for (let i = 0; i < 10; i++) {
            // Create and delete 100 memos
            const memoIds = [];
            for (let j = 0; j < 100; j++) {
                await provider.createMemo();
                memoIds.push(provider.getMemos()[j].id);
            }
            
            for (const id of memoIds) {
                await provider.deleteMemo(id);
            }
        }
        
        global.gc(); // Force garbage collection
        const finalMemory = process.memoryUsage().heapUsed;
        const memoryIncrease = finalMemory - initialMemory;
        
        assert.isBelow(memoryIncrease, 10 * 1024 * 1024, 'Memory increase should be less than 10MB');
    });
});
```

## 4. エラーケーステスト

### 4.1 エラーハンドリング
```typescript
describe('Error Handling', () => {
    it('should handle storage failure gracefully', async () => {
        // Mock storage failure
        context.workspaceState.update.throws(new Error('Storage full'));
        
        const errorSpy = sinon.spy(vscode.window, 'showErrorMessage');
        
        await provider.createMemo();
        
        assert(errorSpy.calledWith(sinon.match(/Failed to save/)));
    });
    
    it('should handle invalid message format', async () => {
        const invalidMessage = { invalid: 'format' };
        
        assert.doesNotThrow(() => provider.handleMessage(invalidMessage));
    });
    
    it('should handle webview disposal', async () => {
        provider.dispose();
        
        assert.doesNotThrow(() => provider.createMemo());
    });
});
```

## 5. アクセシビリティテスト

### 5.1 キーボードナビゲーション
```typescript
describe('Accessibility', () => {
    it('should support keyboard navigation', async () => {
        await vscode.commands.executeCommand('promptMemo.createMemo');
        await vscode.commands.executeCommand('promptMemo.createMemo');
        
        // Tab through memos
        await pressKey('Tab');
        assert.equal(await getFocusedElement(), 'memo-0');
        
        await pressKey('Tab');
        assert.equal(await getFocusedElement(), 'memo-1');
        
        // Shift+Tab to go back
        await pressKey('Shift+Tab');
        assert.equal(await getFocusedElement(), 'memo-0');
    });
    
    it('should have proper ARIA labels', async () => {
        const elements = await getWebviewElements();
        
        assert.exists(elements.find(e => e.role === 'textbox'));
        assert.exists(elements.find(e => e.ariaLabel === 'Delete memo'));
        assert.exists(elements.find(e => e.ariaLabel === 'Create new memo'));
    });
});
```

## 6. テスト実行計画

### 6.1 開発中
- 単体テスト: コミット前に毎回実行
- 統合テスト: 機能完成時に実行

### 6.2 リリース前
- 全テストスイート実行
- パフォーマンステスト実行
- 手動テスト（異なるOS/VSCodeバージョン）

### 6.3 CI/CD
```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        vscode-version: [stable, insiders]
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 20
      - run: npm ci
      - run: npm test
        env:
          VSCODE_VERSION: ${{ matrix.vscode-version }}
```

## 7. テストカバレッジ目標

- **単体テスト**: 90%以上
- **統合テスト**: 80%以上
- **E2Eテスト**: 主要シナリオ100%

## 8. 既知の制限事項

- Webviewのレンダリングテストは手動確認が必要
- VSCode APIモックの制限により一部機能はE2Eテストのみ
- パフォーマンステストは参考値（環境依存）