# Prompt Memo VSCode拡張機能 実装計画書

## 1. 実装フェーズ

### Phase 1: 基盤構築（基礎）
1. プロジェクト初期設定
   - package.json作成
   - tsconfig.json設定
   - 開発環境構築

2. 基本構造実装
   - extension.ts（エントリーポイント）
   - 型定義ファイル作成
   - 基本的なコマンド登録

### Phase 2: コア機能実装
1. MemoViewProvider実装
   - Webview初期化
   - 基本的なHTML生成
   - メッセージハンドリング基盤

2. メモモデル実装
   - Memoクラス/インターフェース
   - UUID生成ユーティリティ
   - データバリデーション

### Phase 3: UI実装
1. Webview UI作成
   - HTML構造
   - CSSスタイリング
   - JavaScriptインタラクション

2. テーマ対応
   - VSCodeテーマ変数の適用
   - ダーク/ライトモード対応

### Phase 4: データ永続化
1. WorkspaceState統合
   - 保存処理実装
   - 読み込み処理実装
   - エラーハンドリング

2. 状態管理最適化
   - デバウンス処理
   - 差分更新ロジック

### Phase 5: 品質向上
1. エラーハンドリング強化
2. パフォーマンス最適化
3. アクセシビリティ対応

## 2. 実装詳細

### 2.1 extension.ts
```typescript
import * as vscode from 'vscode';
import { MemoViewProvider } from './providers/MemoViewProvider';

export function activate(context: vscode.ExtensionContext) {
    console.log('Prompt Memo extension is now active');
    
    const provider = new MemoViewProvider(context);
    
    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider(
            MemoViewProvider.viewType,
            provider,
            {
                webviewOptions: {
                    retainContextWhenHidden: true
                }
            }
        )
    );
    
    context.subscriptions.push(
        vscode.commands.registerCommand('promptMemo.createMemo', () => {
            provider.createMemo();
        })
    );
    
    context.subscriptions.push(
        vscode.commands.registerCommand('promptMemo.deleteMemo', (id: string) => {
            provider.deleteMemo(id);
        })
    );
}

export function deactivate() {
    console.log('Prompt Memo extension is now deactivated');
}
```

### 2.2 MemoViewProvider.ts
```typescript
import * as vscode from 'vscode';
import { Memo } from '../models/Memo';
import { generateUUID } from '../utils/uuid';

export class MemoViewProvider implements vscode.WebviewViewProvider {
    public static readonly viewType = 'promptMemo.memoView';
    private _view?: vscode.WebviewView;
    private _memos: Memo[] = [];
    
    constructor(
        private readonly _context: vscode.ExtensionContext
    ) {
        this.loadMemos();
    }
    
    public resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken,
    ) {
        this._view = webviewView;
        
        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [
                vscode.Uri.joinPath(this._context.extensionUri, 'out', 'webview')
            ]
        };
        
        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);
        
        webviewView.webview.onDidReceiveMessage(
            message => this.handleMessage(message),
            null,
            this._context.subscriptions
        );
        
        this.updateWebview();
    }
    
    private handleMessage(message: any) {
        switch (message.command) {
            case 'createMemo':
                this.createMemo();
                break;
            case 'updateMemo':
                this.updateMemo(message.id, message.content);
                break;
            case 'deleteMemo':
                this.deleteMemo(message.id);
                break;
            case 'loadMemos':
                this.updateWebview();
                break;
        }
    }
    
    public createMemo() {
        const memo: Memo = {
            id: generateUUID(),
            content: '',
            createdAt: Date.now(),
            updatedAt: Date.now()
        };
        
        this._memos.push(memo);
        this.saveMemos();
        this.updateWebview();
    }
    
    public updateMemo(id: string, content: string) {
        const memo = this._memos.find(m => m.id === id);
        if (memo) {
            memo.content = content;
            memo.updatedAt = Date.now();
            this.saveMemos();
        }
    }
    
    public deleteMemo(id: string) {
        const index = this._memos.findIndex(m => m.id === id);
        if (index !== -1) {
            this._memos.splice(index, 1);
            this.saveMemos();
            this.updateWebview();
        }
    }
    
    private async loadMemos() {
        const stored = this._context.workspaceState.get<Memo[]>('memos', []);
        this._memos = stored;
    }
    
    private async saveMemos() {
        await this._context.workspaceState.update('memos', this._memos);
    }
    
    private updateWebview() {
        if (this._view) {
            this._view.webview.postMessage({
                command: 'setMemos',
                memos: this._memos
            });
        }
    }
    
    private _getHtmlForWebview(webview: vscode.Webview) {
        const styleUri = webview.asWebviewUri(
            vscode.Uri.joinPath(this._context.extensionUri, 'out', 'webview', 'webview.css')
        );
        const scriptUri = webview.asWebviewUri(
            vscode.Uri.joinPath(this._context.extensionUri, 'out', 'webview', 'webview.js')
        );
        
        const nonce = getNonce();
        
        return `<!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta http-equiv="Content-Security-Policy" 
                      content="default-src 'none'; 
                               style-src ${webview.cspSource} 'unsafe-inline'; 
                               script-src 'nonce-${nonce}';">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <link href="${styleUri}" rel="stylesheet">
                <title>Prompt Memo</title>
            </head>
            <body>
                <div id="memo-container"></div>
                <script nonce="${nonce}" src="${scriptUri}"></script>
            </body>
            </html>`;
    }
}

function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
```

### 2.3 型定義
```typescript
// types/index.ts
export interface Memo {
    id: string;
    content: string;
    createdAt: number;
    updatedAt: number;
}

export interface WebviewMessage {
    command: 'createMemo' | 'updateMemo' | 'deleteMemo' | 'loadMemos';
    id?: string;
    content?: string;
}

export interface ExtensionMessage {
    command: 'setMemos' | 'memoCreated' | 'memoUpdated' | 'memoDeleted';
    memos?: Memo[];
    memo?: Memo;
    id?: string;
}
```

### 2.4 ユーティリティ関数
```typescript
// utils/uuid.ts
export function generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
```

## 3. コーディング規約

### 3.1 TypeScript
- strictモードを有効化
- 明示的な型定義を使用
- async/awaitパターンを優先
- エラーハンドリングは必須

### 3.2 命名規則
- クラス: PascalCase
- インターフェース: PascalCase（Iプレフィックスなし）
- 変数/関数: camelCase
- 定数: UPPER_SNAKE_CASE
- プライベートメンバー: _prefixed

### 3.3 ファイル構成
- 1ファイル1クラス/モジュール
- 関連する型定義は同じファイルに配置
- テストファイルは*.test.ts

## 4. 依存関係管理

### 4.1 必須パッケージ
```json
{
    "devDependencies": {
        "@types/vscode": "^1.90.0",
        "@types/node": "20.x",
        "@typescript-eslint/eslint-plugin": "^7.0.0",
        "@typescript-eslint/parser": "^7.0.0",
        "eslint": "^8.56.0",
        "typescript": "^5.4.0",
        "@vscode/test-electron": "^2.3.0",
        "glob": "^10.3.0",
        "mocha": "^10.2.0"
    }
}
```

### 4.2 オプショナルパッケージ
- webpack: バンドルサイズ最適化用
- prettier: コードフォーマット統一用

## 5. デバッグ設定

### 5.1 launch.json
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Run Extension",
            "type": "extensionHost",
            "request": "launch",
            "args": [
                "--extensionDevelopmentPath=${workspaceFolder}"
            ],
            "outFiles": [
                "${workspaceFolder}/out/**/*.js"
            ],
            "preLaunchTask": "${defaultBuildTask}"
        }
    ]
}
```

### 5.2 tasks.json
```json
{
    "version": "2.0.0",
    "tasks": [
        {
            "type": "npm",
            "script": "watch",
            "problemMatcher": "$tsc-watch",
            "isBackground": true,
            "presentation": {
                "reveal": "never"
            },
            "group": {
                "kind": "build",
                "isDefault": true
            }
        }
    ]
}
```